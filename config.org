#+TITLE:yu emacs config
#+STARTUP:overview
* 基础设置
** lex binding

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

** 插件相关
*** 插件源设置
#+begin_src emacs-lisp
(setq package-archives '(
    ("melpa" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/")
    ("gnu" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
    ("org" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/org/")))
#+end_src

*** 安装插件
    如果require一个包,但是这个包不存在,那么就会报错,后面的代码就不会执行了. 这个函数用来替换原来的require函数,出错之后只会报警告
#+begin_src emacs-lisp
(defun yu-require (feature)
  "Make sure FEATURE is required."
  (unless (featurep feature)
    (condition-case nil
        (require feature)
      (error nil))))

(yu-require 'package)

(defun yu-package-install (package &optional min-version no-refresh)
  "Ask elpa to install given PACKAGE with MIN-VERSION. If NO-REFRESH is nil, `package-refresh-contents' is called."
  (unless (package-installed-p package min-version) ;;没有安装才进行安装
    (unless (or (assoc package package-archive-contents) no-refresh)
      (package-refresh-contents))
    (package-install package)))
#+end_src

** 自定义函数
*** 空闲运行
#+begin_src emacs-lisp
(defvar my-disable-idle-timer (daemonp)
  "Function passed to `my-run-with-idle-timer' is run immediately.")
(defun my-run-with-idle-timer (seconds func)
  "After SECONDS, run function FUNC once."
  (cond
   ((or my-disable-idle-timer)
    (funcall func))
   (t
    (run-with-idle-timer seconds nil func))))
#+end_src

*** 窗口缩放

#+begin_src emacs-lisp
(defun narrow-to-region-indirect-buffer-maybe (start end use-indirect-buffer)
  "Indirect buffer could multiple widen on same file."
  (if (region-active-p) (deactivate-mark))
  (if use-indirect-buffer
      (with-current-buffer (clone-indirect-buffer
                            (generate-new-buffer-name
                             (format "%s-indirect-:%s-:%s"
                                     (buffer-name)
                                     (line-number-at-pos start)
                                     (line-number-at-pos end)))
                            'display)
        (narrow-to-region start end)
        (goto-char (point-min)))
      (narrow-to-region start end)))


(defun narrow-or-widen-dwim (&optional use-indirect-buffer)
  "If the buffer is narrowed, it widens.
 Otherwise, it narrows to region, or Org subtree.
If USE-INDIRECT-BUFFER is t, use `indirect-buffer' to hold widen content."
  (interactive "P")
  (cond
   ((and (not use-indirect-buffer) (buffer-narrowed-p))
    (widen))

   ((and (not use-indirect-buffer)
         (eq major-mode 'org-mode)
         (fboundp 'org-src-edit-buffer-p)
         (org-src-edit-buffer-p))
    (org-edit-src-exit))

   ;; narrow to region
   ((region-active-p)
    (narrow-to-region-indirect-buffer-maybe (region-beginning)
                                            (region-end)
                                            use-indirect-buffer))

   ;; narrow to specific org element
   ((derived-mode-p 'org-mode)
    (cond
     ((ignore-errors (org-edit-src-code)) t)
     ((ignore-errors (org-narrow-to-block) t))
     ((ignore-errors (org-narrow-to-element) t))
     (t (org-narrow-to-subtree))))

   ((derived-mode-p 'diff-mode)
    (let* (b e)
      (save-excursion
        ;; If the (point) is already beginning or end of file diff,
        ;; the `diff-beginning-of-file' and `diff-end-of-file' return nil
        (setq b (progn (diff-beginning-of-file) (point)))
        (setq e (progn (diff-end-of-file) (point))))
      (when (and b e (< b e))
        (narrow-to-region-indirect-buffer-maybe b e use-indirect-buffer))))

   ((derived-mode-p 'prog-mode)
    (mark-defun)
    (narrow-to-region-indirect-buffer-maybe (region-beginning)
                                            (region-end)
                                            use-indirect-buffer))
   (t (error "Please select a region to narrow to"))))

#+end_src

** 把玩插件设置

#+begin_src emacs-lisp
(defun add-subdirs-to-load-path (search-dir)
  (interactive)
  (let* ((dir (file-name-as-directory search-dir)))
    (dolist (subdir
             ;; 过滤出不必要的目录，提升 Emacs 启动速度
             (cl-remove-if
              #'(lambda (subdir)
                  (or
                   ;; 不是目录的文件都移除
                   (not (file-directory-p (concat dir subdir)))
                   ;; 父目录、 语言相关和版本控制目录都移除
                   (member subdir '("." ".."
                                    "dist" "node_modules" "__pycache__"
                                    "RCS" "CVS" "rcs" "cvs" ".git" ".github"))))
              (directory-files dir)))
      (let ((subdir-path (concat dir (file-name-as-directory subdir))))
        ;; 目录下有 .el .so .dll 文件的路径才添加到 `load-path' 中，提升 Emacs 启动速度
        (when (cl-some #'(lambda (subdir-file)
                           (and (file-regular-p (concat subdir-path subdir-file))
                                ;; .so .dll 文件指非 Elisp 语言编写的 Emacs 动态库
                                (member (file-name-extension subdir-file) '("el" "so" "dll"))))
                       (directory-files subdir-path))

          ;; 注意：`add-to-list' 函数的第三个参数必须为 t ，表示加到列表末尾
          ;; 这样 Emacs 会从父目录到子目录的顺序搜索 Elisp 插件，顺序反过来会导致 Emacs 无法正常启动
          (add-to-list 'load-path subdir-path t))

        ;; 继续递归搜索子目录
        (add-subdirs-to-load-path subdir-path)))))

(add-subdirs-to-load-path (concat (getenv "HOME") "/yuwiki/system/emacs/yuemacs"))
#+end_src

** 外观
*** 杂项
    #+begin_src emacs-lisp
  ;; (linum-mode 1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (horizontal-scroll-bar-mode -1)
  (menu-bar-mode -1)
  (setq inhibit-startup-screen t)


    #+end_src

*** minibuffer 位置修改

    #+begin_src emacs-lisp :tangle no
(require 'vertico-posframe)
(vertico-posframe-mode 1)

    #+end_src

*** 中英字体设置

#+begin_src emacs-lisp

  (condition-case nil
      (progn
	;; 可能出错的配置代码
	;; 设置字体大小   值在1/10 pt，所以100会给你10 pt
	(set-face-attribute 'default nil :height 150)
	(set-face-attribute 'default nil :font "JetBrainsMono Nerd Font Mono")
	(set-fontset-font t '(#x4e00 . #x9fff) "PingFang SC"))
    (error
	(message "Warning: some error in font set")))

  ;; 为org-mode、latex等设置字体（适合学术写作的字体，跟new time roman类似）：
  ;; (add-hook 'text-mode-hook
  ;;     (lambda ()
  ;; 	(setq buffer-face-mode-face '(:family "Georgia Pro"))
  ;; 	(buffer-face-mode)))

#+end_src

*** emoji字体设置
    #+begin_src emacs-lisp :tangle no
(progn
  ;; set font for emoji (if before emacs 28, should come after setting symbols. emacs 28 now has 'emoji . before, emoji is part of 'symbol)
  (set-fontset-font
   t
   (if (version< emacs-version "28.1")
       '(#x1f300 . #x1fad0)
     'emoji
     )
   (cond
    ((member "Apple Color Emoji" (font-family-list)) "Apple Color Emoji")
    ((member "Noto Color Emoji" (font-family-list)) "Noto Color Emoji")
    ((member "Noto Emoji" (font-family-list)) "Noto Emoji")
    ((member "Segoe UI Emoji" (font-family-list)) "Segoe UI Emoji")
    ((member "Symbola" (font-family-list)) "Symbola"))))
    #+end_src

*** 主题与配色

    #+begin_src emacs-lisp
  ;;高亮加粗当前行
  (global-hl-line-mode 1)
  ;; (set-face-attribute 'hl-line nil :inherit nil  :bold t :background nil :foreground nil)

  ;;设置配色方案
  (yu-package-install 'ef-themes)
  ;; (load-theme 'ef-spring t)
  (load-theme 'srcery t)

    #+end_src

*** 鼠标提示

    #+begin_src emacs-lisp
  ;; 光标提示
  (yu-package-install  'beacon)
  (beacon-mode 1)
  (setq beacon-color "#FF4500")


    #+end_src

*** 透明

    #+begin_src emacs-lisp

(set-frame-parameter (selected-frame) 'alpha '(80 . 80))
(add-to-list 'default-frame-alist '(alpha . (80 . 80)))

(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist '(fullscreen . maximized))

    #+end_src

** 窗口
*** 安装插件

#+begin_src emacs-lisp
(yu-package-install 'winum)
#+end_src

*** 设置

#+begin_src emacs-lisp
(with-eval-after-load 'winum
  (setq winum-format "%s")
  (setq winum-mode-line-position 0)
  (set-face-attribute 'winum-face nil :foreground "DeepPink" :underline "DeepPink" :weight 'bold))
(my-run-with-idle-timer 0.5 #'winum-mode)
#+end_src

** 文件
*** 最近打开的文件

#+begin_src emacs-lisp
(yu-require 'recentf)
(recentf-mode 1)
(setq recentf-max-menu-item 10)
#+end_src

*** 自动加载外部修改
    #+begin_src emacs-lisp
(global-auto-revert-mode 1)
    #+end_src

*** 重新打开刚刚关闭的文件
    重新打开是指:在emacs不关闭的情况下,打开刚刚关闭的文件
#+begin_src emacs-lisp
(defvar yu-last-closed-file-list nil)

(defun yu-last-closed-file-track ()
  (when buffer-file-name
    (push buffer-file-name yu-last-closed-file-list)))

(defun yu-last-closed-file-reopen ()
  (interactive)
  (if yu-last-closed-file-list
      (find-file (pop yu-last-closed-file-list))
    (user-error "No last closed file to reopen")))

(define-minor-mode yu-last-closed-file-mode
  "Reopen last closed file."
  :global t
  (if yu-last-closed-file-mode
      (add-hook 'kill-buffer-hook #'yu-last-closed-file-track)
    (remove-hook 'kill-buffer-hook #'yu-last-closed-file-track)))
(yu-last-closed-file-mode)

#+end_src

*** 备份文件
    备份文件形如:filename~
#+begin_src emacs-lisp
;; 不生成备份文件
(setq make-backup-files nil)
#+end_src

*** 自动保存文件
   Auto-saving 可以帮你自动保存：每当你输入一些内容或者停止输入一段时间后，Emacs 会帮你自动保存（到另一个单独的文件(#filename#)，不是原文件），此时如果 Emacs 异常退出了，再打开 Emacs 时，Emacs 就会问你是不是需要恢复文件。如果你手动保存比 Auto-saving 还频繁的话，确实没必要开着 Auto-saveing 了。
#+begin_src emacs-lisp
;; 关闭备份文件
(setq auto-save-default nil)
#+end_src

*** 文件锁
   lock file 是在出现编辑同一个文件时，Emacs 提供的保护措施。比如说，你先用 Emacs 编辑会文件，并没保存，之后又在用 Vim 编辑并保存了同一个文件，这时你回到 Emacs 试图保存文件，Emacs 会警告你：这个文件已经在别的地方修改了，一旦你直接保存，就会失去在 Vim 里的修改，你就有机会决定如何处理这个冲突。
** 其他
*** yes no 相关
   #+begin_src emacs-lisp
;; 使用y代替yes
(fset 'yes-or-no-p 'y-or-n-p)
;; 让回车键表示输入 y
(define-key y-or-n-p-map [return] 'act)
   #+end_src

* Evil相关
** 基本设置
   设置undo历史记录数
#+begin_src emacs-lisp
(setq undo-limit 8000000
      undo-strong-limit 8000000
      undo-outer-limit 8000000)
#+end_src

   设置文本查看格式
#+begin_src emacs-lisp
(defvar my-search-text-history nil "List of text I searched.")
(defun my-select-from-search-text-history ()
  "My select the history of text searching."
  (interactive)
  (ivy-read "Search text history:" my-search-text-history
            :action (lambda (item)
                      (copy-yank-str item)
                      (message "%s => clipboard & yank ring" item))))

(defun my-cc-isearch-string (&rest args)
  "Add `isearch-string' into history."
  (ignore args)
  (and isearch-string
       (> (length isearch-string) 0)
       (push isearch-string my-search-text-history)))
#+end_src

** evil
*** 安装

#+begin_src emacs-lisp
(yu-package-install 'evil)
(yu-package-install 'undo-fu)
(yu-package-install 'expand-region)
#+end_src

*** 常规设置
    切换至normal模式时，光标会回退一位,与vim行为保持一致
    #+begin_src emacs-lisp
      (evil-mode 1)
      (setq evil-move-cursor-back t)
      ;; 在某些特定的模式下，并不需要开启evil以编辑文本，下面这一串配置使evil在这些模式下使用指定的模式；emacs代表emacs默认的编辑模式，而normal则是evil的normal模式
      (defvar my-initial-evil-state-setup
	'((minibuffer-inactive-mode . emacs)
	  (calendar-mode . emacs)
	  (special-mode . emacs)
	  (grep-mode . emacs)
	  (Info-mode . emacs)
	  (term-mode . emacs)
	  (anaconda-nav-mode . emacs)
	  (log-edit-mode . emacs)
	  (magit-log-edit-mode . emacs)
	  (help-mode . emacs)
	  (eshell-mode . emacs)
	  (shell-mode . emacs)
	  (fundamental-mode . emacs)
	  (woman-mode . emacs)
	  (dired-mode . emacs)
	  (exwm-mode . emacs)
	  (messages-buffer-mode . normal))
	"Default evil state per major mode.")

      (with-eval-after-load 'evil
	;; replace undo-tree with undo-fu  @see https://github.com/emacs-evil/evil/issues/1074
	(setq evil-undo-system 'undo-redo)
	(define-key evil-normal-state-map "u" 'undo-fu-only-undo)
	(define-key evil-normal-state-map (kbd "C-r") 'undo-fu-only-redo)

	;; initial evil state per major mode
	(dolist (p my-initial-evil-state-setup)
	  (evil-set-initial-state (car p) (cdr p)))

	;; evil re-assign "M-." to `evil-repeat-pop-next' which I don't use actually. Restore "M-." to original binding command
	(define-key evil-normal-state-map (kbd "M-.") 'xref-find-definitions)
	(setq expand-region-contract-fast-key "z") ;; 使用z在可视模式下修改所选区域   expand-region-custom.el中定义的
	;; evil 1.0.8 search word instead of symbol  @see https://bitbucket.org/lyro/evil/issue/360/possible-evil-search-symbol-forward
	(setq evil-symbol-word-search t)

	;; don't add replaced text to `kill-ring'
	(setq evil-kill-on-visual-paste nil)

	;; @see https://emacs.stackexchange.com/questions/9583/how-to-treat-underscore-as-part-of-the-word
	;; uncomment below line to make "dw" has exact same behavior in evil as as in vim
	;; (defalias #'forward-evil-word #'forward-evil-symbol)

	;; @see https://bitbucket.org/lyro/evil/issue/511/let-certain-minor-modes-key-bindings
	(defmacro adjust-major-mode-keymap-with-evil (m &optional r)
	  `(with-eval-after-load (quote ,(if r r m))
	     (evil-make-overriding-map ,(intern (concat m "-mode-map")) 'normal)
	     ;; force update evil keymaps after git-timemachine-mode loaded
	     (add-hook (quote ,(intern (concat m "-mode-hook"))) #'evil-normalize-keymaps)))
	(adjust-major-mode-keymap-with-evil "git-timemachine")
	(setq evil-default-cursor t))
    #+end_src

*** 定义常规text objects
   定义text objects, works on evil v1.0.9 using older method
   例 =abc=  光标在a上,按住vi=,则选取abc
   #+begin_src emacs-lisp
(defmacro my-evil-define-and-bind-text-object (key start-regex end-regex)
  (let* ((inner-name (make-symbol "inner-name"))
         (outer-name (make-symbol "outer-name")))
    `(progn
       (evil-define-text-object ,inner-name (count &optional beg end type)
         (evil-select-paren ,start-regex ,end-regex beg end type count nil))
       (evil-define-text-object ,outer-name (count &optional beg end type)
         (evil-select-paren ,start-regex ,end-regex beg end type count t))
       (define-key evil-inner-text-objects-map ,key (quote ,inner-name))
       (define-key evil-outer-text-objects-map ,key (quote ,outer-name)))))

(my-evil-define-and-bind-text-object "=" "=" "=")
(my-evil-define-and-bind-text-object "|" "|" "|")
(my-evil-define-and-bind-text-object "/" "/" "/")
(my-evil-define-and-bind-text-object "l" "^ *" " *$") ;;选取一行
(my-evil-define-and-bind-text-object "r" "\{\{" "\}\}")

#+end_src

*** 定义文件路径text objects
   将文件路径做为text object
     - "vif" to select base name
     - "vaf" to select full path
   example:
     "/hello/world"
     "C:hello\\hello\\world\\test.exe"
   #+begin_src emacs-lisp
(defun my-evil-path-is-separator-char (ch)
  "Check ascii table that CH is slash characters.
If the character before and after CH is space or tab, CH is NOT slash"
  (let* (rlt prefix-ch postfix-ch)
    (when (and (> (point) (point-min)) (< (point) (point-max)))
      (save-excursion
        (backward-char)
        (setq prefix-ch (following-char)))
      (save-excursion
        (forward-char)
        (setq postfix-ch (following-char))))
    (if (and (not (or (= prefix-ch 32) (= postfix-ch 32)))
             (or (= ch 47) (= ch 92)) )
        (setq rlt t))
    rlt))

(defun my-evil-path-not-path-char (ch)
  "Check ascii table for character CH."
  (or (and (<= 0 ch) (<= ch 32))
      (memq ch
            '(34 ; double quotes
              ?'
              40 ; (
              41 ; )
              ?<
              ?>
              91 ; [
              93 ; ]
              ?`
              ?{
              ?}
              127))))

(defun my-evil-path-calculate-path (b e)
  (let* (rlt f)
    (when (and b e)
      (setq b (+ 1 b))
      (when (save-excursion
              (goto-char e)
              (setq f (my-evil-path-search-forward-char 'my-evil-path-is-separator-char t))
              (and f (>= f b)))
        (setq rlt (list b (+ 1 f) (- e 1)))))
    rlt))

(defun my-evil-path-get-path-already-inside ()
  (let* (b e)
    (save-excursion
      (setq b (my-evil-path-search-forward-char 'my-evil-path-not-path-char t)))
    (save-excursion
      (when (setq e (my-evil-path-search-forward-char 'my-evil-path-not-path-char))
        (goto-char (- e 1))
        ;; example: hello/world,
        (if (memq (following-char) '(?, ?.))
            (setq e (- e 1)))))
    (my-evil-path-calculate-path b e)))

(defun my-evil-path-search-forward-char (fn &optional backward)
  (let* (found
         rlt
         (limit (if backward (point-min) (point-max)))
         out-of-loop)
    (save-excursion
      (while (not out-of-loop)
        ;; for the char, exit
        (if (setq found (apply fn (list (following-char))))
            (setq out-of-loop t)
          ;; reach the limit, exit
          (if (= (point) limit)
              (setq out-of-loop t)
            ;; keep moving
            (if backward (backward-char) (forward-char)))))
      (if found (setq rlt (point))))
    rlt))

(defun my-evil-path-extract-region ()
  "Find the closest file path."
  (let* (rlt b f1 f2)
    (if (and (not (my-evil-path-not-path-char (following-char)))
             (setq rlt (my-evil-path-get-path-already-inside)))
        ;; maybe (point) is in the middle of the path
        t
      ;; need search forward AND backward to find the right path
      (save-excursion
        ;; path in backward direction
        (when (setq b (my-evil-path-search-forward-char #'my-evil-path-is-separator-char t))
          (goto-char b)
          (setq f1 (my-evil-path-get-path-already-inside))))
      (save-excursion
        ;; path in forward direction
        (when (setq b (my-evil-path-search-forward-char #'my-evil-path-is-separator-char))
          (goto-char b)
          (setq f2 (my-evil-path-get-path-already-inside))))
      ;; pick one path as the final result
      (cond
       ((and f1 f2)
        (if (> (- (point) (nth 2 f1)) (- (nth 0 f2) (point)))
            (setq rlt f2)
          (setq rlt f1)))
       (f1
        (setq rlt f1))
       (f2
        (setq rlt f2))))

    rlt))

(evil-define-text-object my-evil-path-inner-text-object (&optional count begin end type)
  "File name of nearby path"
  (let* ((selected-region (my-evil-path-extract-region)))
    (if selected-region
        (evil-range (nth 1 selected-region) (nth 2 selected-region) :expanded t))))

(evil-define-text-object my-evil-path-outer-text-object (&optional count begin end type)
  "Nearby path."
  (let* ((selected-region (my-evil-path-extract-region)))
    (when selected-region
      (evil-range (car selected-region) (+ 1 (nth 2 selected-region)) type :expanded t))))

(define-key evil-inner-text-objects-map "f" 'my-evil-path-inner-text-object)
(define-key evil-outer-text-objects-map "f" 'my-evil-path-outer-text-object)

#+end_src

*** 各模式快捷键

   #+begin_src emacs-lisp
;; 配置evil-ex模式下的快捷键
(define-key evil-ex-completion-map (kbd "C-a") 'move-beginning-of-line)
(define-key evil-ex-completion-map (kbd "C-b") 'backward-char)
(define-key evil-ex-completion-map (kbd "M-p") 'previous-complete-history-element)
(define-key evil-ex-completion-map (kbd "M-n") 'next-complete-history-element)

;; 配置evil-normal模式下的快捷键
(define-key evil-normal-state-map (kbd "C-]") 'counsel-etags-find-tag-at-point)
(define-key evil-normal-state-map "gh" 'beginning-of-defun)
(define-key evil-normal-state-map "=" 'text-scale-increase)
(define-key evil-normal-state-map "-" 'text-scale-decrease)

;; 配置evil-visual模式下的快捷键
(define-key evil-visual-state-map (kbd "v") 'er/expand-region)
(define-key evil-visual-state-map (kbd "C-]") 'counsel-etags-find-tag-at-point)

;; 配置evil-insert模式下的快捷键
(define-key evil-insert-state-map (kbd "C-e") 'move-end-of-line)

;; 配置evil-emacs模式下的快捷键
(define-key evil-emacs-state-map (kbd "M-j") 'yas-expand)
(define-key evil-ex-completion-map (kbd "C-a") 'back-to-indentation)

;; 设置evil的插入模式使用emacs原生按键
;; remove all keybindings from insert-state keymap,it is VERY VERY important
(setcdr evil-insert-state-map nil)
;; 把emacs模式下的按键绑定到Insert模式下
(define-key evil-insert-state-map
  (read-kbd-macro evil-toggle-key) 'evil-emacs-state)
;; but [escape] should switch back to normal state
(define-key evil-insert-state-map [escape] 'evil-normal-state)
(define-key evil-insert-state-map (kbd "C-w") 'backward-kill-word)
(define-key evil-insert-state-map (kbd "C-u") 'evil-delete-back-to-indentation)
(define-key evil-insert-state-map (kbd "C-a") 'back-to-indentation)
(define-key evil-insert-state-map (kbd "C-l") 'delete-char)
(define-key evil-insert-state-map (kbd "C-v") 'evil-paste-after)
(define-key evil-insert-state-map (kbd "C-j") 'avy-copy-line)
(define-key evil-insert-state-map (kbd "M-j") 'avy-copy-region)
(define-key evil-insert-state-map (kbd "C-k") 'avy-move-line)
(define-key evil-insert-state-map (kbd "M-k") 'avy-move-region)
(define-key evil-insert-state-map (kbd "C-<return>") (lambda () (interactive) (end-of-line) (newline-and-indent)))
(define-key evil-insert-state-map (kbd "S-<return>") (lambda () (interactive) (beginning-of-line) (newline-and-indent) (previous-line)))
#+end_src

*** 设置evil的标记历史显示格式

#+begin_src emacs-lisp
(defvar evil-global-markers-history nil)
(defun my-evil-set-marker-hack (char &optional pos advance)
  "Place evil marker's position into history."
  (ignore advance)
  (unless pos (setq pos (point)))
  ;; only remember global markers
  (when (and (>= char ?A) (<= char ?Z) buffer-file-name)
    (setq evil-global-markers-history
          (delq nil
                (mapcar `(lambda (e)
                           (unless (string-match (format "^%s@" (char-to-string ,char)) e)
                             e))
                        evil-global-markers-history)))
    (setq evil-global-markers-history
          (add-to-list 'evil-global-markers-history
                       (format "%s@%s:%d:%s"
                               (char-to-string char)
                               (file-truename buffer-file-name)
                               (line-number-at-pos pos)
                               (string-trim (my-line-str)))))))
(advice-add 'evil-set-marker :before #'my-evil-set-marker-hack)

#+end_src

*** 定义自己的文本对象v 代表某个语句
#+begin_src emacs-lisp
(evil-define-text-object my-evil-a-statement (count &optional beg end type)
  "Select a statement."
  (list (my-skip-white-space (line-beginning-position) 1)
        (line-end-position)))

(defun my-skip-white-space (start step)
  "Skip white spaces from START, return position of first non-space character.
If STEP is 1,  search in forward direction, or else in backward direction."
  (let* ((b start)
         (e (if (> step 0) (line-end-position) (line-beginning-position))))
    (save-excursion
      (goto-char b)
      (while (and (not (eq b e)) (memq (following-char) '(9 32)))
        (forward-char step))
      (point))))

(evil-define-text-object my-evil-inner-statement (count &optional beg end type)
  "Select inner statement."
  (let* ((b (my-skip-white-space (line-beginning-position) 1))
         (e (line-end-position)))
    (list (save-excursion
            (goto-char b)
            (while (and (< (point) e) (not (eq (following-char) 61)))
              (forward-char))
            (cond
             ((eq (point) e)
              b)
             (t
              ;; skip '=' at point
              (goto-char (my-skip-white-space (1+ (point)) 1))
              (point))))
          (cond
           ((eq (char-before e) 59) ; ";"
            (my-skip-white-space (1- e) -1))
           (t
            e)))))

(define-key evil-outer-text-objects-map "v" #'my-evil-a-statement)
(define-key evil-inner-text-objects-map "v" #'my-evil-inner-statement)

#+end_src

*** 定义自己的文本对象i 代表引号(单 双引号)内的对象

#+begin_src emacs-lisp

    (defun my-what-face (&optional position)
      "Show all faces at POSITION."
      (let* ((face (get-text-property (or position (point)) 'face)))
	(unless (keywordp (car-safe face)) (list face))))


  (defun my-create-range (&optional inclusive)
    "Return range by font face.
  Copied from 3rd party package evil-textobj."
    (let* ((point-face (my-what-face))
	   (pos (point))
	   (backward-none-space-point pos) ; last none white space char
	   (forward-none-space-point pos) ; last none white space char
	   (start pos)
	   (end pos))

      ;; check chars backward,
      ;; stop when char is not white space and has different face
      (save-excursion
	(let ((continue t))
	  (while (and continue (>= (- (point) 1) (point-min)))
	    (backward-char)
	    (unless (= 32 (char-after))
	      (if (equal point-face (my-what-face))
		  (setq backward-none-space-point (point))
		(setq continue nil))))))

      ;; check chars forward,
      ;; stop when char is not white space and has different face
      (save-excursion
	(let ((continue t))
	  (while (and continue (< (+ (point) 1) (point-max)))
	    (forward-char)
	    (let ((forward-point-face (my-what-face)))
	      (unless (= 32 (char-after))
		(if (equal point-face forward-point-face)
		    (setq forward-none-space-point (point))
		  (setq continue nil)))))))

      (cond
       (inclusive
	(setq start backward-none-space-point)
	(setq end forward-none-space-point))
       (t
	(setq start (1+ backward-none-space-point))
	(setq end (1- forward-none-space-point))))

      (cons start (1+ end))))

      (defun my-text-obj-similar-font (count beg end type inclusive)
	"Get maximum range of single or double quote text object.
      If INCLUSIVE is t, the text object is inclusive."
	(ignore count beg end type)
	(let* ((range (my-create-range inclusive)))
	  (evil-range (car range) (cdr range) inclusive)))

      (evil-define-text-object my-evil-a-single-or-double-quote (count &optional beg end type)
	"Select a single-quoted expression."
	:extend-selection t
	(my-text-obj-similar-font count beg end type t))

      (evil-define-text-object my-evil-inner-single-or-double-quote (count &optional beg end type)
	"Select 'inner' single-quoted expression."
	:extend-selection nil
	(my-text-obj-similar-font count beg end type nil))

      (define-key evil-outer-text-objects-map "i" #'my-evil-a-single-or-double-quote)
      (define-key evil-inner-text-objects-map "i" #'my-evil-inner-single-or-double-quote)

#+end_src

*** 定义自己的文本对象g 代表括号内的对象

#+begin_src emacs-lisp
(defun my-evil-paren-range (count beg end type inclusive)
  "Get minimum range of paren text object.
COUNT, BEG, END, TYPE is used.  If INCLUSIVE is t, the text object is inclusive.
FN is function to get range."
  (let* ((parens '("()" "[]" "{}" "<>" "\"\"" "''" "``"))
         (pos (point))
         range
         found-range)
    (dolist (p parens)
      (condition-case nil
          (let* ((c1 (aref p 0))
                 (c2 (aref p 1)))
            (setq range (if (eq c1 c2) (evil-select-quote c1 beg end type count inclusive)
                          (evil-select-paren c1 c2 beg end type count inclusive))))
        (error nil))
      (when (and range (<= (nth 0 range) pos) (< pos (nth 1 range)))
        (cond
         (found-range
          (when (< (- (nth 1 range) (nth 0 range))
                   (- (nth 1 found-range) (nth 0 found-range)))
            (setf (nth 0 found-range) (nth 0 range))
            (setf (nth 1 found-range) (nth 1 range))))
         (t
          (setq found-range range)))))
    found-range))

(evil-define-text-object my-evil-a-paren (count &optional beg end type)
  "Select a paren."
  :extend-selection t
  (my-evil-paren-range count beg end type t))

(evil-define-text-object my-evil-inner-paren (count &optional beg end type)
  "Select 'inner' paren."
  :extend-selection nil
  (my-evil-paren-range count beg end type nil))

(define-key evil-inner-text-objects-map "g" #'my-evil-inner-paren)
(define-key evil-outer-text-objects-map "g" #'my-evil-a-paren)

#+end_src

*** 根据evil的模式来改变modeline颜色

#+begin_src emacs-lisp

(defconst my-default-color (cons (face-background 'mode-line)
                                 (face-foreground 'mode-line)))
(defun my-show-evil-state ()
  "Change mode line color to notify user evil current state."
  (let* ((color (cond ((minibufferp) my-default-color)
                      ((evil-insert-state-p) '("#e80000" . "#ffffff"))
                      ((evil-emacs-state-p)  '("#444488" . "#ffffff"))
                      ((buffer-modified-p)   '("#006fa0" . "#ffffff"))
                      (t my-default-color))))
    (set-face-background 'mode-line (car color))
    (set-face-foreground 'mode-line (cdr color))))
(add-hook 'post-command-hook #'my-show-evil-state)
#+end_src

*** EX命令设置
    主要针对evil的ex命令使用   需要自行调用
    #+begin_src emacs-lisp
(defun my-evil-ex-command-completion-at-point ()
  "Completion function for ex command history."
  (let* ((start (or (get-text-property 0 'ex-index evil-ex-cmd)
                    (point)))
         (end (point)))
    (list start end evil-ex-history :exclusive 'no)))

(defun my-search-evil-ex-history ()
  "Search `evil-ex-history' to complete ex command."
  (interactive)
  (let (after-change-functions
        (completion-styles '(substring))
        (completion-at-point-functions '(my-evil-ex-command-completion-at-point)))
    (evil-ex-update)
    (completion-at-point)
    (remove-text-properties (minibuffer-prompt-end) (point-max) '(face nil evil))))

(defun my-optimize-evil ()
  "I prefer mixed Emacs&Vi style.  Run this function in \"~/.custom.el\"."
  (with-eval-after-load 'evil
    ;; TAB key still triggers `evil-ex-completion'.
    (define-key evil-ex-completion-map (kbd "C-d") 'delete-char)
    ;; use `my-search-evil-ex-history' to replace `evil-ex-command-window'
    (define-key evil-ex-completion-map (kbd "C-f") 'forward-char)
    (define-key evil-ex-completion-map (kbd "C-s") 'evil-ex-command-window)
    ;; I use Emacs in terminal which may not support keybinding "C-r" or "M-n"
    (define-key evil-ex-completion-map (kbd "C-r") 'my-search-evil-ex-history)
    (define-key evil-ex-completion-map (kbd "M-n") 'my-search-evil-ex-history)))

#+end_src

*** 可视模式
    可视模式下选择的内容不添加到evil register中
    #+begin_src emacs-lisp
(defvar my-evil-enable-visual-update-x-selection nil
  "Automatically copy the selected text into evil register. I'm not sure this is good idea.")
(defun my-evil-visual-update-x-selection-hack (orig-func &rest args)
  (when my-evil-enable-visual-update-x-selection
    (apply orig-func args)))
(advice-add 'evil-visual-update-x-selection :around #'my-evil-visual-update-x-selection-hack)
#+end_src

*** evil-declare-key
   使用evil-declare-key，可以非常方便地定义某个模式下evil的按键
   leader keys started with upper cased character or 'g' or special character except "=" and "-"
   #+begin_src emacs-lisp
     ;; 如下配置，在org-mode中normal模式下，按TAB键可以直接执行org-cycle命令，去展开或折叠某个heading
     (evil-declare-key 'normal org-mode-map
       "gh" 'outline-up-heading
       "$" 'org-end-of-line ; smarter behavior on headlines etc.
       "^" 'org-beginning-of-line ; ditto
       "<" (lambda () (interactive) (org-demote-or-promote 1)) ; out-dent
       ">" 'org-demote-or-promote ; indent
       (kbd "TAB") 'org-cycle)

     (evil-declare-key 'normal markdown-mode-map
       "gh" 'outline-up-heading
       (kbd "TAB") 'markdown-cycle)
   #+end_src

** evil-surround
*** 安装

#+begin_src emacs-lisp
(yu-package-install 'evil-surround)
#+end_src

*** 基本设置
   evil-surround 类于vim-surround，可以在evil模式下方便地操作匹配的符号
   evil-surround快捷键说明
       cs for change surround 修改包围字符   cs"'
       ds for delete surround 删除包围字符
       ys for your surround 添加包围字符     ysiW"
   下面的配置为org-mode和emacs-lisp-mode分别加入一些匹配的符号，以便于surround可以操纵它
#+begin_src emacs-lisp
(my-run-with-idle-timer 2 #'global-evil-surround-mode)
(with-eval-after-load 'evil-surround
  (defun evil-surround-prog-mode-hook-setup ()
    "Set up surround shortcuts."
    (cond
     ((memq major-mode '(sh-mode))
      (push '(?$ . ("$(" . ")")) evil-surround-pairs-alist))
     (t
      (push '(?$ . ("${" . "}")) evil-surround-pairs-alist)))

    (when (memq major-mode '(org-mode))
      (push '(?\[ . ("[[" . "]]")) evil-surround-pairs-alist)
      (push '(?= . ("=" . "=")) evil-surround-pairs-alist))

    (when (memq major-mode '(emacs-lisp-mode))
      (push '(?\( . ("( " . ")")) evil-surround-pairs-alist)
      (push '(?` . ("`" . "'")) evil-surround-pairs-alist))

    ;; generic
    (push '(?/ . ("/" . "/")) evil-surround-pairs-alist))
  (add-hook 'prog-mode-hook 'evil-surround-prog-mode-hook-setup))

#+end_src

** evil-visualstar
*** 安装

#+begin_src emacs-lisp
(yu-package-install 'evil-visualstar)
#+end_src

*** 基本设置
   选择一段文本,按#(上)或者*(下)搜索
#+begin_src emacs-lisp
(setq evil-visualstar/persistent t)
(my-run-with-idle-timer 2 #'global-evil-visualstar-mode)
#+end_src

   设置文本查看格式
#+begin_src emacs-lisp
(advice-add 'evil-visualstar/begin-search :after #'my-cc-isearch-string)
#+end_src

** evil-escape
*** 安装

#+begin_src emacs-lisp
(yu-package-install 'evil-escape)
#+end_src

*** 设置
   设置退出插入模式的按键  disable evil-escape when input method is on
   #+begin_src emacs-lisp
;; (global-set-key (kbd "C-c C-g") 'evil-escape) ;; 可这样设置全局快捷键
(setq-default evil-escape-delay 0.3)
(setq evil-escape-excluded-major-modes '(dired-mode))
(setq-default evil-escape-key-sequence "kj")
(evil-escape-mode 1)
   #+end_src

** evil-mark-replace
*** 安装

#+begin_src emacs-lisp
(yu-package-install 'evil-mark-replace)
#+end_src

** evil-search

#+begin_src emacs-lisp
(advice-add 'evil-search-incrementally :after #'my-cc-isearch-string)
(advice-add 'evil-search-word :after #'my-cc-isearch-string)
#+end_src

** evil-nerd-commenter
*** 安装

#+begin_src emacs-lisp
(yu-package-install 'evil-nerd-commenter)
#+end_src

*** 设置
   快速进行注释，不依赖于evil
#+begin_src emacs-lisp
(my-run-with-idle-timer 2 #'evilnc-default-hotkeys)
(define-key evil-motion-state-map "gc" 'evilnc-comment-operator) ; same as doom-emacs
(define-key evil-motion-state-map "gb" 'evilnc-copy-and-comment-operator)
(define-key evil-motion-state-map "gy" 'evilnc-yank-and-comment-operator)
#+end_src

   注释段落
   #+begin_src emacs-lisp
(defun my-current-line-html-p (paragraph-region)
  "Is current line html?"
  (let* ((line (buffer-substring-no-properties (line-beginning-position)
                                               (line-end-position)))
         (re (format "^[ \t]*\\(%s\\)?[ \t]*</?[a-zA-Z]+"
                     (regexp-quote (evilnc-html-comment-start)))))
    ;; current paragraph does contain html tag
    (if (and (>= (point) (car paragraph-region))
             (string-match re line))
        t)))

(defun my-evilnc-comment-or-uncomment-paragraphs (&optional num)
  "Comment or uncomment NUM paragraphs which might contain html tags."
  (interactive "p")
  (yu-require 'evil-nerd-commenter)
  (let* ((paragraph-region (evilnc--get-one-paragraph-region))
         (html-p (ignore-errors
                   (or (save-excursion
                         (sgml-skip-tag-backward 1)
                         (my-current-line-html-p paragraph-region))
                       (save-excursion
                         (sgml-skip-tag-forward 1)
                         (my-current-line-html-p paragraph-region))))))
    (if html-p (evilnc-comment-or-uncomment-html-paragraphs num)
      (evilnc-comment-or-uncomment-paragraphs num))))

#+end_src

** evil-matchit
*** 安装

#+begin_src emacs-lisp
(yu-package-install 'evil-matchit)
#+end_src

*** 设置
   按%进行匹配跳转
   #+begin_src emacs-lisp
     (my-run-with-idle-timer 2 #'global-evil-matchit-mode)
   #+end_src

** evil-exchange
*** 安装
   类vim-exchange，可以方便地交换两处字符  按两次gx即可 gX取消
#+begin_src emacs-lisp
(yu-package-install 'evil-exchange)
#+end_src

*** 设置

#+begin_src emacs-lisp
;; (setq evil-exchange-key (kbd "zx"))   ;; 更改默认的绑定按键
(my-run-with-idle-timer 4 #'evil-exchange-install)
#+end_src

** evil-find-char-pinyin-mode
   Evil’s f/F/t/T command can search PinYin

*** 安装

#+begin_src emacs-lisp
(yu-package-install 'evil-find-char-pinyin)
#+end_src

#+begin_src emacs-lisp
(my-run-with-idle-timer 4 #'evil-find-char-pinyin-mode)
#+end_src

* 中文输入
** pyim

   #+begin_src emacs-lisp

     (yu-package-install 'pyim)
     (yu-package-install 'pyim-basedict)
     (defun my-toggle-input-method ()
       "When input method is on, goto `evil-insert-state'."
       (interactive)
       ;; load IME when needed, less memory footprint
       (yu-require 'pyim)
       ;; some guys don't use evil-mode at all
       (cond
	;; 对于major mode，用derived-mode-p    对于minor mode，直接检查同名变量是否为真
	((and (not (derived-mode-p 'exwm-mode)) (boundp 'evil-mode) evil-mode)
	 ;; 非exwm-mode, 并且启用了evil-mode
	 (cond
	  ((eq evil-state 'insert)
	   (toggle-input-method))
	  (t
	   (evil-insert-state)
	   (unless current-input-method
	     (toggle-input-method))))
	 (cond
	  (current-input-method
	   ;; evil-escape and pyim may conflict
	   ;; @see https://github.com/redguardtoo/emacs.d/issues/629
	   (evil-escape-mode -1)
	   (message "IME on!"))
	  (t
	   (evil-escape-mode 1)
	   (message "IME off!"))))
	(t
	 ;; NOT evil-mode
	 (toggle-input-method))))

     (global-set-key (kbd "C-SPC") 'my-toggle-input-method)

     ;; pyim相关
     (defvar my-pyim-directory "~/yuwiki/system/eim"
       "The directory containing pyim dictionaries.")

     (with-eval-after-load 'pyim
       (defun my-pyim-clear-and-off ()
	 "Clear and off."
	 (interactive)
	 (pyim-quit-clear)
	 (my-toggle-input-method))

       ;; press "/" to turn off pyim
       ;; (define-key pyim-mode-map (kbd "/") 'my-pyim-clear-and-off)

       ;; use western punctuation
       (setq pyim-punctuation-dict nil)
       (setq default-input-method "pyim")

       (cond
	(t
	 (setq pyim-pinyin-fuzzy-alist
	       '(("en" "eng")
		 ("in" "ing")))

	 ;; Dictionaries:
	 ;;   pyim-greatdict is not recommended. It has too many useless words and slows down pyim.
	 ;;
	 ;;   Download pyim-bigdict,
	 ;;   curl -L http://tumashu.github.io/pyim-bigdict/pyim-bigdict.pyim.gz | zcat > ~/.eim/pyim-bigdict.pyim
	 ;;
	 ;;   Download pyim-tsinghua (recommended),
	 ;;   curl -L https://raw.githubusercontent.com/redguardtoo/pyim-tsinghua-dict/master/pyim-tsinghua-dict.pyim > ~/.eim/pyim-tsinghua-dict.pyim

	 ;; don's use shortcode2word
	 (setq pyim-enable-shortcode nil)

	 ;; use memory efficient pyim engine for pinyin IME
	 (yu-require 'pyim-dregcache)
	 (setq pyim-dcache-backend 'pyim-dregcache)

	 ;; automatically load pinyin dictionaries "*.pyim" under "~/.eim/"
	 (let* ((files (and (file-exists-p my-pyim-directory)
			    (directory-files-recursively my-pyim-directory "\.pyim$")))
		disable-basedict)
	   (when (and files (> (length files) 0))
	     (setq pyim-dicts
		   (mapcar (lambda (f)
			     (list :name (file-name-base f) :file f))
			   files))
	     (dolist (f files)
	       (when (member (file-name-base f) '("pyim-another-dict"
						  "pyim-tsinghua-dict.pyim"
						  "pyim-bigdict"
						  "pyim-greatdict"))
		 (setq disable-basedict t))))
	   (unless disable-basedict (pyim-basedict-enable)))))

       ;; 设置C-h可以删除输入拼音时的单个字符
       (define-key pyim-mode-map "\C-h" 'pyim-delete-backward-char)

       (setq pyim-page-tooltip '(minibuffer posframe popup))
       )
   #+end_src

* 补全
** 括号自动补全

#+begin_src emacs-lisp
(electric-pair-mode t)
#+end_src

** vertico  增强minibuffer

#+begin_src emacs-lisp
  (yu-package-install 'vertico)
  (vertico-mode t)
#+end_src

#+begin_src emacs-lisp
  (yu-package-install 'vertico-posframe)
  (when (display-graphic-p)
    (yu-require 'vertico-posframe)
    (vertico-posframe-mode 1)
    (setq vertico-posframe-font "JetBrainsMono Nerd Font Mono 22"))
#+end_src

** orderless  模糊搜索

#+begin_src emacs-lisp
  (yu-package-install 'orderless)
  (setq completion-styles '(orderless))

  ;; vertico 支持拼音搜索
  (yu-package-install 'pinyinlib)
  (yu-require 'pinyinlib)

  (defun completion--regex-pinyin (str)
    (orderless-regexp (pinyinlib-build-regexp-string str)))
  (with-eval-after-load 'orderless
    (add-to-list 'orderless-matching-styles 'completion--regex-pinyin))
#+end_src

** marginalia  增强minibuffer中的注释信息

#+begin_src emacs-lisp
(yu-package-install 'marginalia)
(marginalia-mode t)
#+end_src

** consult  增强文件内搜索和跳转函数定义

#+begin_src emacs-lisp
(yu-package-install 'consult)
(global-set-key (kbd "C-s") 'consult-line)

;; 关闭最近打开文件时的预览功能
(with-eval-after-load 'consult
  (consult-customize consult-recent-file :preview-key nil))

(defun yu-consult-line-symbol-at-point ()
  "Consult line the synbol where the point is"
  (interactive)
  (consult-line (thing-at-point 'symbol)))

(defun yu-consult-find-orgs-headings (&optional match)
  "find headngs in all org files on current directory."
  (interactive)
  (consult-org-heading match (directory-files org-directory t "^[0-9]\\{8\\}.+\\.org$")))
#+end_src

** corfu buffer内补全

   #+begin_src emacs-lisp :tangle no
(setq corfu-auto t)

;; TAB cycle if there are only few candidates
(setq completion-cycle-threshold 3)


;; Enable indentation+completion using the TAB key.  `completion-at-point' is often bound to M-TAB.
(setq tab-always-indent 'complete)

(global-corfu-mode)

;; orderless separator
(define-key corfu-map (kbd "M-SPC") 'corfu-insert-separator)
   #+end_src

** cape 补全后端

   #+begin_src emacs-lisp
  ;; Add to the global default value of `completion-at-point-functions' which is
  ;; used by `completion-at-point'.  The order of the functions matters, the
  ;; first function returning a result wins.  Note that the list of buffer-local
  ;; completion functions takes precedence over the global list.
  ;; (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  ;; (add-to-list 'completion-at-point-functions #'cape-file)
  ;; (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  ;;(add-to-list 'completion-at-point-functions #'cape-history)
  ;; (add-to-list 'completion-at-point-functions #'cape-keyword)
  ;;(add-to-list 'completion-at-point-functions #'cape-tex)
  ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
  ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
  ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
  ;;(add-to-list 'completion-at-point-functions #'cape-dict)
  ;; (add-to-list 'completion-at-point-functions #'cape-elisp-symbol)
  ;; (add-to-list 'completion-at-point-functions #'cape-line)
   #+end_src

* 跳转
** 安装

#+begin_src emacs-lisp
(yu-package-install 'avy)
(yu-package-install 'ace-pinyin)
#+end_src

** 配置

#+begin_src emacs-lisp
(autoload 'ace-pinyin-jump-char-2 "ace-pinyin" "" t)
#+end_src

* Org相关
** 功能设置
*** 解决加载慢

#+begin_src emacs-lisp
(setq org-modules-loaded t)
#+end_src

*** org tempo
    开启<s补全代码
#+begin_src emacs-lisp
(require 'org-tempo)
#+end_src

    禁用左尖括号;这里需要先打开 electric-pair-mode 才能继续设置
#+begin_src emacs-lisp
(setq electric-pair-inhibit-predicate
      `(lambda (c)
	 (if (char-equal c ?\<) t (,electric-pair-inhibit-predicate c))))

(add-hook 'org-mode-hook
	  (lambda ()
	    (setq-local electric-pair-inhibit-predicate
			`(lambda (c)
			   (if (char-equal c ?\<) t (,electric-pair-inhibit-predicate c))))))
#+end_src

*** 关闭导出 html 时的validation

#+begin_src emacs-lisp
(setq org-html-validation-link nil)
#+end_src

*** 导出html时的标题范围

    #+begin_src emacs-lisp
    (setq org-export-headline-levels 5)
    #+end_src

*** 自动缩进

    #+begin_src emacs-lisp
      (setq org-adapt-indentation t)
      (setq org-src-preserve-indentation t)
    #+end_src

** 外观定制
*** 标题字体大小
    设置Org mode标题以及每级标题行的大小
    #+begin_src emacs-lisp
(custom-set-faces '(org-document-title ((t (:height 1.75 :weight bold))))
		  '(org-level-1 ((t (:height 1.2 :weight bold))))
		  '(org-level-2 ((t (:height 1.15 :weight bold))))
		  '(org-level-3 ((t (:height 1.1 :weight bold))))
		  '(org-level-4 ((t (:height 1.05 :weight bold))))
		  '(org-level-5 ((t (:height 1.0 :weight bold))))
		  '(org-level-6 ((t (:height 1.0 :weight bold))))
		  '(org-level-7 ((t (:height 1.0 :weight bold))))
		  '(org-level-8 ((t (:height 1.0 :weight bold))))
		  '(org-level-9 ((t (:height 1.0 :weight bold))))
		  ;; '(org-block-begin-line ((t (:underline t :background unspecified)))) ;; 设置代码块用上下边线包裹
		  ;; '(org-block-end-line ((t (:overline t :underline nil :background unspecified))))
		  )

    #+end_src

*** 强调
   使用下面的包来自定义一些强调符号和其对应的外观
   该库只定义了前2个,可以支持17的,有需要的自己增加就行
   #+begin_src emacs-lisp
   (yu-require 'org-extra-emphasis)
   #+end_src

*** 导出时代码高亮
    安装 htmlize 插件即可
    #+begin_src emacs-lisp
    (yu-package-install 'htmlize)
    #+end_src

** Babel
   org-babel: 按需加载所有的语言  [[https://emacs-china.org/t/org-babel/18699/8][参考]]
   #+begin_src emacs-lisp
(defun yu-org-mode-setup ()
  (when (eq major-mode 'org-mode)
    (local-set-key (kbd "<f5>") 'org-ctrl-c-ctrl-c)))

(add-hook 'org-mode-hook 'yu-org-mode-setup)


(defun yu-org-babel-execute-src-block (&optional _arg info _params)
  "Load language if needed"
  (let* ((lang (nth 0 info))
         (sym (if (member (downcase lang) '("c" "cpp" "c++")) 'C (intern lang)))
         (backup-languages org-babel-load-languages))
    ;; - (LANG . nil) 明确禁止的语言，不加载。
    ;; - (LANG . t) 已加载过的语言，不重复载。
    (unless (assoc sym backup-languages)
      (condition-case err
          (progn
            (org-babel-do-load-languages 'org-babel-load-languages (list (cons sym t)))
            (setq-default org-babel-load-languages (append (list (cons sym t)) backup-languages)))
        (file-missing
         (setq-default org-babel-load-languages backup-languages)
         err)))))

(advice-add 'org-babel-execute-src-block :before #'yu-org-babel-execute-src-block )
   #+end_src

** 自定义函数
*** org拖拽功能

#+begin_src emacs-lisp
(defun yu-dnd-handler (url _action)
  (let* ((filename (file-name-nondirectory (decode-coding-string (url-unhex-string url) 'utf-8))) ;; 处理中文字符
         (filepath (concat
                   (cond
                    ((equal (file-name-extension url) "html") "../htmls/")
                    (t "./tmp/misc/"))
                   filename)))
    (url-copy-file url filepath)
    (insert
     (if (equal (file-name-extension url) "html")
	     (concat "[[file:" filepath "]["(substring filename 0 -5)"]]")
	   (concat "[[file:" filepath "]]")))))
(setq dnd-protocol-alist
      '(("" . yu-dnd-handler)))
#+end_src

*** 仅显示当前subtree中的图片

#+begin_src emacs-lisp
(defun yu-org-display-subtree-inline-images ()
  "Toggle the display of inline images.
INCLUDE-LINKED is passed to `org-display-inline-images'."
  (interactive)
  (save-excursion
    (save-restriction
      (org-narrow-to-subtree)
      (let* ((beg (point-min))
             (end (point-max))
             (image-overlays (cl-intersection
                              org-inline-image-overlays
                              (overlays-in beg end))))
        (if image-overlays
            (progn
              (org-remove-inline-images)
              (message "Inline image display turned off"))
          (org-display-inline-images t t beg end)
          (setq image-overlays (cl-intersection
                                org-inline-image-overlays
                                (overlays-in beg end)))
          (if (and (org-called-interactively-p) image-overlays)
              (message "%d images displayed inline"
                       (length image-overlays))))))))
#+end_src

*** 导出src block并打开文件
    emacs命令可以使用C-u传递universal-argument.
| Key Input               | Value of current-prefix-arg |
|-------------------------+-----------------------------|
| No universal arg called | nil                         |
| 【Ctrl+u -】            | Symbol -                    |
| 【Ctrl+u - 2】          | Number -2                   |
| 【Ctrl+u 1】            | Number 1                    |
| 【Ctrl+u 4】            | Number 4                    |
| 【Ctrl+u】              | List '(4)                   |
| 【Ctrl+u Ctrl+u】       | List '(16)                  |

    如果要为加了 universal argument C-u 的命令绑定快捷键, 重点是认识到 C-u 的作用是为其后接的交互式命令加了一个 argument, 这个 argument 是 '(4), 按 C-u 两次是 '(16), 按 C-u 三次是 '(64)

    以命令 org-latex-preview 为例:
      1. C-u org-latex-preview 等价于 M-: (org-latex-preview '(4)), 取消当前 headline 下的所有 fragments 的图片显示 (显示 latex 源码)
      2. C-u C-u org-latex-preview 等价于 M-: (org-latex-preview '(16)) , 在当前 buffer 内用图片显示所有的 latex fragments.
      3. C-u C-u C-u org-latex-preview 等价于 M-: (org-latex-preview '(64)), 取消当前 buffer 内的所有 latex fragments 的图片显示 (显示 latex 源码)

    #+begin_src emacs-lisp
(defun yu-org-babel-goto-tangle-file ()
  (interactive)
  (org-babel-tangle '(4))
  (if-let* ((args (nth 2 (org-babel-get-src-block-info t)))
	    (tangle (alist-get :tangle args)))
      (when (not (equal "no" tangle))
	(find-file tangle)
	t)))

;; (add-hook 'org-open-at-point-functions 'yu-org-babel-goto-tangle-file)
    #+end_src

** 定制文件打开方式

   #+begin_src emacs-lisp :tangle no
     (add-to-list 'org-file-apps '("\\.pdf" . default))
   #+end_src

* 文件管理
** dired

   #+begin_src emacs-lisp
;; 开两个窗口后, 自动猜测另一个窗口路径为默认目标地址
(setq dired-dwim-target t)

;; 让dired以友好形式显示文件大小
(setq dired-listing-switches "-alh")
   #+end_src

** dirvish

   #+begin_src emacs-lisp
(yu-package-install 'dirvish)
(dirvish-override-dired-mode)
(setq dirvish-preview-disabled-exts '("iso" "bin" "exe" "gpg" "elc" "eln" "pdf" "html" "mobi" "epub" "azw3"))

(define-key dirvish-mode-map (kbd "l") 'dired-find-file)
(define-key dirvish-mode-map (kbd "h") 'dired-up-directory)
(define-key dirvish-mode-map (kbd "j") 'dired-next-line)
(define-key dirvish-mode-map (kbd "k") 'dired-previous-line)

(define-key dirvish-mode-map (kbd "TAB") 'dirvish-subtree-toggle)
(define-key dirvish-mode-map (kbd "t") 'dirvish-layout-toggle)
(define-key dirvish-mode-map (kbd "f") 'dirvish-narrow)
(define-key dirvish-mode-map (kbd "g") 'dirvish-fd)
(define-key dirvish-mode-map (kbd "i") 'wdired-change-to-wdired-mode)

   #+end_src

* 项目
** Git
*** vc-msg
#+begin_src emacs-lisp
(yu-package-install 'vc-msg)
(autoload 'vc-msg-show "vc-msg" "")
#+end_src

** Project
  project-find-file  是emacs内置的一个函数
* 快捷键
** 基础
   设置Eval快捷键
#+begin_src emacs-lisp
(global-set-key (kbd "<f5>") 'eval-defun)
#+end_src

   设置C-h
#+begin_src emacs-lisp
  (global-set-key (kbd "C-h") 'delete-backward-char)
  (global-set-key (kbd "M-m") 'help-command)
  (define-key isearch-mode-map "\C-h" 'isearch-delete-char)
#+end_src

   快速打开配置文件
#+begin_src emacs-lisp
(defun open-init-file()
  (interactive)
  (find-file "~/yuwiki/system/emacs/config.org"))
(global-set-key (kbd "<f12>") 'open-init-file)
#+end_src

   其他
#+begin_src emacs-lisp

(global-set-key (kbd "<f9>") 'embark-act)

;; 打开shell窗口
(global-set-key (kbd "<f1>") 'aweshell-dedicated-toggle)

;; 查询英文单词含义
(global-set-key (kbd "<f2>") 'lsp-bridge-toggle-sdcv-helper)

#+end_src

   仿照windows常用的按键
   #+begin_src emacs-lisp  :tangle no
(global-set-key (kbd "s-a") 'mark-whole-buffer) ;;对应Windows上面的Ctrl-a 全选
(global-set-key (kbd "s-c") 'kill-ring-save) ;;对应Windows上面的Ctrl-c 复制
(global-set-key (kbd "s-s") 'save-buffer) ;; 对应Windows上面的Ctrl-s 保存
(global-set-key (kbd "s-v") 'yank) ;对应Windows上面的Ctrl-v 粘贴
(global-set-key (kbd "s-z") 'undo) ;对应Windows上面的Ctrol-z 撤销
(global-set-key (kbd "s-x") 'kill-region) ;对应Windows上面的Ctrol-x 剪切
   #+end_src

** General
   general提供了类leader键的方法，使用leader键可以减少按Ctrl和Alt等控制键的次数；不依赖于evil，可直接为Emacs配置快捷键
#+begin_src emacs-lisp
(yu-package-install 'general)
(general-evil-setup t)
#+end_src

   可针对不同的主模式设置不同的快捷键
#+begin_src emacs-lisp
(general-create-definer my-org-leader-def
  :prefix ";"
  :non-normal-prefix "M-;"
  :states '(normal motion visual)
  :keymaps 'org-mode-map)

(my-org-leader-def
  "f" 'my-navigate-in-pdf
  "g" 'my-open-pdf-goto-page)

#+end_src

** 逗号

#+begin_src emacs-lisp
(general-create-definer my-comma-leader-def
  :prefix ","
  :states '(normal visual))

(my-comma-leader-def
  "wf" 'popup-which-function)

#+end_src

** 分号

#+begin_src emacs-lisp
(general-create-definer my-semicolon-leader-def
  :prefix ";"
  :states '(normal visual))
(my-semicolon-leader-def
  "gq" 'w3m-stackoverflow-search)
#+end_src

** 空格
#+begin_src emacs-lisp
  (general-create-definer my-space-leader-def
    :prefix "SPC"
    :states '(normal visual))
  (my-space-leader-def
    "SPC" 'ace-pinyin-jump-char-2

    ;;----------------
    ;; action + obj
    ;;----------------

    ;; lsp相关
    "lf" 'lsp-bridge-code-format

    ;; kill---x    k用作移动时的上
    "kk" 'consult-yank-pop ;; kill buffer
    "xs" 'whitespace-cleanup ;;清除文件中多余的空格

    ;; f---find
    "rr" 'yu-last-closed-file-reopen
    "dd" 'dired
    "ds" 'dirvish-side
    "ff" 'yu-find-file ;; fuzzy
    "fd" 'find-file ;; dir
    "fr" 'consult-recent-file
    "si" 'consult-imenu
    "ss" 'consult-line
    "sp" 'yu-consult-line-symbol-at-point
    "bf" 'beginning-of-defun
    "ef" 'end-of-defun
    "bb" 'switch-to-buffer
    "bx" 'kill-buffer
    "bm" 'consult-minor-mode-menu
    "rb" 'evilmr-replace-in-buffer
    "fs" 'save-buffer
    "TAB" (lambda () (interactive) (switch-to-buffer nil)) ; 切换上一个buffer
    "ls" 'highlight-symbol
    "lq" 'highlight-symbol-query-replace
    "ln" 'highlight-symbol-nav-mode ; use m-n/m-p to navigation between symbols
    "cl" 'evilnc-comment-or-uncomment-lines;;注释当前行
    "ci" 'evilnc-quick-comment-or-uncomment-to-the-line;;注释一个区域
    "cc" 'evilnc-copy-and-comment-lines;;注释并拷贝当前行

    ;; 开关选项配置
    "tl" 'toggle-truncate-lines

    ;; Org 相关配置
    "oo" 'org-open-at-point-and-delete-other-windows
    "ot" 'yu-org-babel-goto-tangle-file
    "oe" 'org-html-export-to-html
    "oa" 'org-agenda
    "ov" 'yu-org-display-subtree-inline-images

    ;; 其他
    "mm" 'consult-man
    "vv" 'vc-msg-show
    ;; "di" 'evilmi-delete-items
    ;; "si" 'evilmi-select-items

    ;; 窗口操作
    "wr" 'rotate-windows
    "ws" 'delete-other-windows
    "wj" 'split-window-vertically
    "wl" 'split-window-horizontally
    "ww" 'narrow-or-widen-dwim ;单独显示一个函数
    "wx" 'delete-window
    "0" 'winum-select-window-0-or-10
    "1" 'winum-select-window-1
    "2" 'winum-select-window-2
    "3" 'winum-select-window-3
    "4" 'winum-select-window-4
    "5" 'winum-select-window-5
    "6" 'winum-select-window-6
    "7" 'winum-select-window-7
    "8" 'winum-select-window-8
    "9" 'winum-select-window-9
    )

#+end_src

** key-echo

   #+begin_src emacs-lisp :tangle no
     (yu-require 'key-echo)
     (key-echo-enable)

     (defun key-echo-shift-to-switch-input-method (key)
       (interactive)
	(message "ceshi")
       (when (string-equal key "Key.shift")
	 (toggle-input-method)
	 ))

     (setq key-echo-single-key-trigger-func 'key-echo-shift-to-switch-input-method)
   #+end_src

* 非源插件
** lsp-bridge
   git clone https://github.com/manateelazycat/lsp-bridge
   sudo apt install clangd
   sudo apt install python3-pip
   pip install  -i https://pypi.tuna.tsinghua.edu.cn/simple epc

   #+begin_src emacs-lisp
     (yu-package-install  'posframe)
     (yu-package-install  'markdown-mode)
     (yu-package-install  'yasnippet)

     (require 'yasnippet)
     (yas-global-mode 1)
     (require 'lsp-bridge)
     (global-lsp-bridge-mode)

     (setq acm-candidate-match-function 'orderless-prefixes)
     (setq acm-enable-quick-access t)
     (setq acm-quick-access-use-number-select t)
     (setq acm-enable-icon nil)

   #+end_src

** aweshell
   git clone https://github.com/manateelazycat/aweshell
  #+begin_src emacs-lisp
(yu-package-install 'consult-dir)
(yu-require 'consult-dir)

(yu-package-install 'esh-autosuggest)
(yu-require 'esh-autosuggest)
(add-hook 'eshell-mode-hook #'esh-autosuggest-mode)
(define-key esh-autosuggest-active-map (kbd "C-o") 'company-complete-selection)
(define-key esh-autosuggest-active-map (kbd "C-n") 'esh-autosuggest-complete-word)

(defun eshell/z (&optional regexp)
    "Navigate to a previously visited directory in eshell, or to
any directory proferred by `consult-dir'."
    (let ((eshell-dirs (delete-dups
                        (mapcar 'abbreviate-file-name
                                (ring-elements eshell-last-dir-ring)))))
      (cond
       ((and (not regexp) (featurep 'consult-dir))
        (let* ((consult-dir--source-eshell `(:name "Eshell"
                                             :narrow ?e
                                             :category file
                                             :face consult-file
                                             :items ,eshell-dirs))
               (consult-dir-sources (cons consult-dir--source-eshell
                                          consult-dir-sources)))
          (eshell/cd (substring-no-properties
                      (consult-dir--pick "Switch directory: ")))))
       (t (eshell/cd (if regexp (eshell-find-previous-directory regexp)
                            (completing-read "cd: " eshell-dirs)))))))

(yu-require 'aweshell)
  #+end_src

  #+RESULTS:
  : aweshell

** auto-save
   git clone https://github.com/manateelazycat/auto-save
   #+begin_src  emacs-lisp
(yu-require 'auto-save)
(auto-save-enable)

(setq auto-save-silent t)   ; quietly save
(setq auto-save-delete-trailing-whitespace t)  ; automatically delete spaces at the end of the line when saving

;;; custom predicates if you don't want auto save.
;;; disable auto save mode when current filetype is an gpg file.
(setq auto-save-disable-predicates
      '((lambda ()
      (string-suffix-p
      "gpg"
      (file-name-extension (buffer-name)) t))))
   #+end_src

* 自定义函数
** 与外部命令行交互

   #+begin_src emacs-lisp
;; 把选中区域中的内容传给命令行工具,并将其执行的结果替换原有选中区域
(defun yu-execute-external-command-on-region ()
  "Execute the specified external command on the contents of the current region, replacing the region contents with the result."
  (interactive)
  (when (region-active-p)
    (let ((start (region-beginning))
          (end (region-end))
          (command (read-shell-command "Shell command: ")))
      (let ((output-buffer (generate-new-buffer "*External Command Output*")))
        ;; Run the command in a shell using the contents of the region as input
        (call-process-region start end shell-file-name nil output-buffer nil
                             shell-command-switch command)
        ;; Replace the region contents with the command output
        (delete-region start end)
        (insert-buffer-substring output-buffer)))))

;; 执行外部命令,并将其结果插入到当前buffer
(defun yu-insert-command-output (cmd)
  "Insert the output of external command CMD at the end of the current buffer."
  (interactive "sEnter command to run: ")
  (let ((output (shell-command-to-string cmd)))
    (save-excursion
      (goto-char (point-max))
      (insert output))))


   #+end_src

** compile 相关
*** compile 无错误则正常关闭窗口
    如果编译没有错误,则隐藏complie窗口
    hide the compilation buffer automatically is not a good idea.
    if compiling command is a unit test command
    it's better let user decide when to hide something
    #+begin_src emacs-lisp :tangle no
(winner-mode t)
(defvar yu-do-bury-compilation-buffer t
  "Hide compilation buffer if compile successfully.")

(defun yu-compilation-finish-hide-buffer-on-success (buffer str)
  "Bury BUFFER whose name marches STR.
This function can be re-used by other major modes after compilation."
  (cond
   ;;there were errors
   ((string-match "exited abnormally" str)
    (message "There IS compilation errors, press C-x ` to visit!"))

   ;;no errors, make the compilation window go away in 0.5 seconds
   (t
    (when (and yu-do-bury-compilation-buffer
               (buffer-name buffer)
               (string-match "*compilation*" (buffer-name buffer)))
      ;; @see http://emacswiki.org/emacs/ModeCompile#toc2
      (bury-buffer "*compilation*")
      (winner-undo)
      (message "NO compilation error.")))))

;; @see http://xugx2007.blogspot.com.au/2007/06/benjamin-rutts-emacs-c-development-tips.html
(setq compilation-finish-functions
      '(yu-compilation-finish-hide-buffer-on-success))

    #+end_src

*** 编译快捷键

     #+begin_src emacs-lisp
(defun yu-smart-compile()
  "比较智能的C/C++编译命令
如果当前目录有makefile则用make -k编译，否则，如果是
处于c-mode，就用gcc -Wall编译，如果是c++-mode就用
g++ -Wall编译"
  (interactive)
  ;; 查找 Makefile
  (let ((candidate-make-file-name '("makefile" "Makefile" "GNUmakefile"))
        (command nil))
    (if (not (null
              (cl-find t candidate-make-file-name :key
                    '(lambda (f) (file-readable-p f)))))
        (setq command "make -k ")
        ;; 没有找到 Makefile ，查看当前 mode 是否是已知的可编译的模式
        (if (null (buffer-file-name (current-buffer)))
            (message "Buffer not attached to a file, won't compile!")
            (if (eq major-mode 'c-mode)
                (setq command
                      (concat "gcc -g -Wall -o "
                              (file-name-sans-extension
                               (file-name-nondirectory buffer-file-name))
                              " "
                              (file-name-nondirectory buffer-file-name)))
              (if (eq major-mode 'c++-mode)
                  (setq command
                        (concat "g++ -g -Wall -o "
                                (file-name-sans-extension
                                 (file-name-nondirectory buffer-file-name))
                                " "
                                (file-name-nondirectory buffer-file-name)))
                (message "Unknow mode, won't compile!")))))
    (if (not (null command))
        (let ((command (read-from-minibuffer "Compile command: " command)))
          (compile command)))))

  (defun yu-compile-key()
    (local-set-key (kbd "<f5>") #'yu-smart-compile))
  (add-hook 'c-mode-common-hook 'yu-compile-key)

     #+end_src

** 使用外部程序打开特定类型文件

   #+begin_src emacs-lisp
     (yu-package-install 'openwith)
     (when (require 'openwith nil 'noerror)
       (setq openwith-associations
	     (list
	      (list (openwith-make-extension-regexp
		     '("pdf" "epub" "djvu" "mobi" "azw3"))
		    "koreader"
		    '(file))

	      (list (openwith-make-extension-regexp
		     '("html" "htm"))
		    "firefox"
		    '(file))
              ))
       (openwith-mode 1))
   #+end_src

** 增强find-file

   #+begin_src emacs-lisp
     (let ((find-files-program
	    (cond ((executable-find "rg") '("rg" "--color=never" "--files"))
		  ((executable-find "find") '("find" "-type" "f")))))
       (defun yu-find-file ()
	 "Find a file in the current working directory recursively."
	 (interactive)
	 (find-file
	  (completing-read "Find file: "
			   (apply #'process-lines find-files-program)))))

   #+end_src

* EXWM
** edwina
   类似dwm样式的窗口管理
   git clone https://github.com/ajgrf/edwina

   #+begin_src emacs-lisp
(yu-require 'edwina)
(setq display-buffer-base-action '(display-buffer-below-selected))
;; (edwina-mode 1)
   #+end_src

** app launcher

   git clone https://github.com/SebastienWae/app-launcher

   #+begin_src emacs-lisp
   (require 'app-launcher)
   (defun yu-run-app ()
     (interactive)
      (split-window-right)
      (windmove-right)
      (app-launcher-run-app)
      (edwina-arrange))
   (global-set-key (kbd "M-SPC") 'yu-run-app)
   #+end_src

** exwm
*** EXWM的前置知识
**** line-mode  Default
     In line-mode, EXWM intercepts all key events and sends applications only keys not explicitly assigned.

     1.Sending all the keys to the apps with some simulations. EXWM calls this line-mode. You can define simulations like.
     #+begin_src emacs-lisp :tangle no
(setq exwm-input-set-simulation-keys
   '(([?\C-b] . left)
     ([?\C-f] . right)))
     #+end_src

     Now in this mode if I press C-f apps receive right arrow key.

     2.Not sending any key to the apps, instead Emacs receives all the keys. So you can use normal operations like C-x 2 or C-x 3 to split the window.EXWM calls this line-mode too.

**** char-mode
     Whereas in char-mode, EXWM does no interception but only responds to those globally grabbed key sequences.

     Sending all the keys to the apps except the global bindings (for e.g. this is a global (exwm-input-set-key (kbd "s-c") #'list-processes).

**** Global key bindings 全局绑定
     全局绑定在  char-mode 与 line-mode 中都生效, 而且在emacs本身的buffer中也生效。

     全局绑定使用 *exwm-input-global-keys* 进行设置, exwm-input-global-keys 要放在 exwm-enable 之前才有效果, 该设置也可能会拖慢启动速度

     为了避免exwm-input-global-keys 的上述缺点, 可以用 *exwm-input-prefix-keys* 来绑定快捷键, 但是需要注意, exwm-input-prefix-keys *仅在* line-mode中有效

**** Local key bindings 本地绑定
     本地绑定仅在 中 line-mode 可用, 设置方法为: (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

     exwm 自定义了一些以C-c开头的快捷键, 可以使用 (define-key exwm-mode-map (kbd "C-c") nil) 将其禁止

**** Simulation keys 模拟按键序列
     你可以使用exwm-input-simulation-keys来设置一个快捷键用以代表一个按键序列, exwm会按键序列发送给x窗口

     exwm-input-simulation-keys 定义的模拟快捷键在所有应用程序之间共享。如果你想要buffer-local的, 可以使用 exwm-input-set-local-simulation-keys

     exwm默认没有定义任何模拟序列

**** Layout modes 布局模式
     exwm支持3种布局模式, 平铺、浮动和全屏

     - 平铺
       没什么特别的, 可以使用C-x b, C-x 1, C-x 2, C-x 3 来调整窗口布局与切换窗口


     - 浮动
       会创建一个 Emacs frame 来运行程序, 可以使用s-<down-mouse-1> 移动 或 s-<down-mouse-3> 调整浮动窗口的大小


     - 全屏
       这个只能算是特性, 在平铺或浮动模式下通过 C-c C-f 触发全屏显示, 使用exwm-reset恢复成之前的布局

**** 工作空间
     EXWM 默认仅显示属于当前工作区的窗口, 可以用 (setq exwm-workspace-show-all-buffers t) 来显示所有工作空间的窗口。此外, 还可以使用 (setq exwm-layout-show-all-buffers t) 来允许切换到其他工作空间的窗口中。

**** 默认的快捷键

     s-<down-mouse-1> 	exwm-input-move-event 	        Move X window
     s-<down-mouse-3> 	exwm-input-resize-event 	Resize X window
                         exwm-restart                    就地重新启动 EXWM
     C-c C-f 	        exwm-layout-set-fullscreen 	Enter fullscreen mode
     C-c C-h 	        exwm-floating-hide 	        Hide a floating X window
     C-c C-k 	        exwm-input-release-keyboard 	Switch to char-mode
     C-c C-m 	        exwm-workspace-move-window 	Move X window to another workspace
     C-c C-q 	        exwm-input-send-next-key 	Send a single key to the X window; can be prefixed with C-u to send multiple keys
     C-c C-t C-f 	exwm-floating-toggle-floating 	Toggle between tiling and floating mode
     C-c C-t C-m 	exwm-layout-toggle-mode-line 	Toggle mode-line

*** EXWM基本设置

    #+begin_src emacs-lisp
(defun xah-user-buffer-q ()
  "Return t if current buffer is a user buffer, else nil.
Typically, if buffer name starts with *, it's not considered a user buffer.
This function is used by buffer switching command and close buffer command, so that next buffer shown is a user buffer.
You can override this function to get your idea of “user buffer”.
version 2016-06-18"
  (interactive)
  (if (string-equal "*" (substring (buffer-name) 0 1))
      nil
    (if (string-equal major-mode "dired-mode")
        nil
      t
      )))

(defun xah-next-user-buffer ()
  "Switch to the next user buffer.
“user buffer” is determined by `xah-user-buffer-q'.
URL `http://xahlee.info/emacs/emacs/elisp_next_prev_user_buffer.html'
Version 2016-06-19"
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (< i 20)
      (if (not (xah-user-buffer-q))
          (progn (next-buffer)
                 (setq i (1+ i)))
        (progn (setq i 100))))))

(defun xah-previous-user-buffer ()
  "Switch to the previous user buffer.
“user buffer” is determined by `xah-user-buffer-q'.
URL `http://xahlee.info/emacs/emacs/elisp_next_prev_user_buffer.html'
Version 2016-06-19"
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (< i 20)
      (if (not (xah-user-buffer-q))
          (progn (previous-buffer)
                 (setq i (1+ i)))
        (progn (setq i 100))))))

(defun yu-run-in-background (command)
  (let ((command-parts (split-string command "[ ]+")))
    (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))


;; 将firefox的窗口名设置为标签页标题
(defun yu-exwm-update-title ()
  (pcase exwm-class-name
    ("firefox" (exwm-workspace-rename-buffer (format "firefox: %s" exwm-title)))))

(defun yu-configure-window-by-class ()
  (interactive)
  (pcase exwm-class-name
    ("firefox" (exwm-workspace-move-window 2))
    ("Sol" (exwm-workspace-move-window 3))
    ("mpv" (exwm-floating-toggle-floating)
           (exwm-layout-toggle-mode-line))))


(require 'exwm)

;; 输入法tray
;; (require 'exwm-systemtray)
;; (exwm-systemtray-enable)

;; 显示所有工作空间的buffer
;; (setq exwm-layout-show-all-buffers t)
;; (setq exwm-workspace-show-all-buffers t)

;; 新窗口名字为打开的程序名称
(defun yu-exwm-update-class ()
  (exwm-workspace-rename-buffer exwm-class-name))

;; Set the default number of workspaces
(setq exwm-workspace-number 5)

;; When window "class" updates, use it to set the buffer name
(add-hook 'exwm-update-class-hook #'yu-exwm-update-class)

;; When window title updates, use it to set the buffer name
(add-hook 'exwm-update-title-hook #'yu-exwm-update-title)

;; Configure windows as they're created
;; (add-hook 'exwm-manage-finish-hook #'yu-configure-window-by-class)

;; 设置模拟序列
(setq exwm-input-simulation-keys
      '(
        ;; ([?\C-p] . [up])
        ;; ([?\C-n] . [down])
        ;; ([?\C-a] . [home])
        ;; ([?\C-e] . [end])
        ([?\C-h] . [backspace])))

;; These keys should always pass through to Emacs
(setq exwm-input-prefix-keys
      '(?\C-x
	;; ?\C-u
	?\C-h
	?\M-x
	?\M-m
	?\M-&
	?\M-:
	?\C-\ ))  ;; Ctrl+Space

;; s-Q will enable the next key to be sent directly
(define-key exwm-mode-map [?\s-q] 'exwm-input-send-next-key)

;; Set up global key bindings.  These always work, no matter the input state!
;; Keep in mind that changing this list after EXWM initializes has no effect.
(setq exwm-input-global-keys
      `(
	;; Reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
	([?\s-r] . exwm-reset)

	;; Move between windows
	([?\s-h] . windmove-left)
	([?\s-l] . windmove-right)
	([?\s-k] . windmove-up)
	([?\s-j] . windmove-down)

	([s-left] . edwina-swap-previous-window)
	([s-right] . edwina-swap-next-window)
	([s-up] . windmove-up)
	([s-down] . windmove-down)

        (,(kbd "s-c") . kill-ring-save)
        (,(kbd "s-v") . yank)

        ;; Toggle the current window between floating and non-floating states
        (,(kbd "s-o") . exwm-floating-toggle-floating)

        ;; Toggle fullscreen mode, when in an EXWM window.
        (,(kbd "s-z") . exwm-layout-toggle-fullscreen)

	;; Launch applications via shell command
	([?\s-\ ] .  app-launcher-run-app)

	;; Switch workspace
	([?\s-w] . exwm-workspace-switch)

        ;; Toggle display of mode-line and minibuffer, in an EXWM window
        (,(kbd "s-m") . (lambda ()
                          (interactive)
                          (exwm-layout-toggle-mode-line)
                          (exwm-workspace-toggle-minibuffer)))

        ;; Toggle between "line-mode" and "char-mode" in an EXWM window
        (,(kbd "s-i") . exwm-input-toggle-keyboard)

        ;; Windows-style M-TAB and M-S-TAB to switch buffers.
        (,(kbd "M-<tab>") . xah-previous-user-buffer)
        (,(kbd "M-<iso-lefttab>") . xah-next-user-buffer)

        (,(kbd "s-<return>") . edwina-arrange)
        (,(kbd "s-<backspace>") . edwina-delete-window)

        (,(kbd "s-x") . kill-buffer-and-window)

	;; 's-N': Switch to certain workspace with Super (Win) plus a number key (0 - 9)
	,@(mapcar (lambda (i)
		    `(,(kbd (format "s-%d" i)) .
		      (lambda ()
			(interactive)
			(exwm-workspace-switch-create ,i))))
		  (number-sequence 0 9))))


(exwm-enable)

(require 'exwm-xim)
(exwm-xim-enable)
(setenv "GTK_IM_MODULE" "xim")
(setenv "QT_IM_MODULE" "xim")
(setenv "XMODIFIERS" "@im=exwm-xim")
(setenv "CLUTTER_IM_MODULE" "xim")

;; (yu-run-in-background "feh --bg-scale ~/yuwiki/system/emacs/bg.png")
;; (yu-run-in-background "compton &")

    #+end_src

** tabs

   #+begin_src emacs-lisp :tangle no
;; This buffer is for text that is not saved, and for Lisp evaluation.
;;; from tabbar-ruler
(defcustom EmacsPortable-included-buffers '("*scratch*")
  "* Included buffers in tabbar."
  :type '(repeat (string :tag "Buffer Name"))
  :group 'EmacsPortable)
(defcustom EmacsPortable-excluded-buffers '("*Messages*" "*Completions*" "*ESS*")
  "* Excluded buffers in tabbar."
  :type '(repeat (string :tag "Buffer Name"))
  :group 'EmacsPortable)
(setq EmacsPortable-excluded-buffers '("*Messages*" "*Completions*" "*ESS*" "*Compile-Log*" "*Ibuffer*" "*SPEEDBAR*" "*etags tmp*" "*reg group-leader*" "*Pymacs*" "*grep*"))
(setq EmacsPortable-included-buffers '("*scratch*" "*shell*"))
(defun ep-tabbar-buffer-list ()
  "Return the list of buffers to show in tabs.
Exclude buffers whose name starts with a space or *, when they are not
visiting a file.  The current buffer is always included."
  (delq nil
        (mapcar #'(lambda (b)
                    (cond
                     ;; Always include the current buffer.
                     ((eq (current-buffer) b) b)
		     ((string-match "^TAGS\\(<[0-9]+>\\)?$" (format "%s" (buffer-name b))) nil)
                     ;; ((string= "TAGS" (format "%s" (buffer-name b))) nil)
                     ((buffer-file-name b) b)
		     ((member (buffer-name b) EmacsPortable-included-buffers) b)
		     ((member (buffer-name b) EmacsPortable-excluded-buffers) nil)
                     ((char-equal ?\  (aref (buffer-name b) 0)) nil)
                     ((char-equal ?* (aref (buffer-name b) 0)) nil)
                     ((buffer-live-p b) b)))
                (buffer-list))))

(when (functionp 'global-tab-line-mode)
  (require 'tab-line)
  (setq tab-line-tabs-function 'ep-tabbar-buffer-list)
  (global-tab-line-mode 1))

   #+end_src

* 测试

  #+begin_src conf :tangle no
git clone https://github.com/kubernetes/kubernetes.git
#改为
git clone https://github.com.cnpmjs.org/kubernetes/kubernetes.git
#或者
git clone https://hub.fastgit.org/kubernetes/kubernetes.git
#或者
git clone https://gitclone.com/github.com/kubernetes/kubernetes.git
  #+end_src
